# -*- coding: utf-8 -*-
"""Big Data Mini-Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pVei5DPLYOUx-iWnhYrb0pN6DDggDcgY

**Mounting Google Drive**
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Extracting Dataset**"""

import zipfile
import os

zip_path = '/content/drive/MyDrive/archive.zip'
extract_path = '/content/PlantVillage'

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print(os.listdir(extract_path + "/plantvillage dataset"))

"""**Loading the Dataset (The Colour Folder)**"""

import tensorflow as tf

# Parameters
img_size = (128, 128)
batch_size = 16

data_dir = '/content/PlantVillage/plantvillage dataset/color'

train_ds = tf.keras.utils.image_dataset_from_directory(
    data_dir,
    validation_split=0.2,
    subset="training",
    seed=123,
    image_size=img_size,
    batch_size=batch_size
)

val_ds = tf.keras.utils.image_dataset_from_directory(
    data_dir,
    validation_split=0.2,
    subset="validation",
    seed=123,
    image_size=img_size,
    batch_size=batch_size
)

# Get class names
class_names = train_ds.class_names
print("Number of classes:", len(class_names))
print("Class names:", class_names)

"""**Limiting the dataset (to avoid any crashes)**"""

# Only use a subset to fit into RAM so that it doesn't crash
train_ds = train_ds.take(500)
val_ds = val_ds.take(125)

"""**Preparing the Data Augmentation**"""

from tensorflow.keras import layers

data_augmentation = tf.keras.Sequential([
    layers.RandomFlip("horizontal_and_vertical"),
    layers.RandomRotation(0.2),
    layers.RandomZoom(0.1),
    layers.RandomContrast(0.1),
])

"""**Visualizing a few images**"""

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 10))
for images, labels in train_ds.take(1):
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        plt.title(class_names[labels[i]])
        plt.axis("off")

"""**Optimizing the dataset performance**"""

AUTOTUNE = tf.data.AUTOTUNE

train_ds = train_ds.prefetch(buffer_size=AUTOTUNE)
val_ds = val_ds.prefetch(buffer_size=AUTOTUNE)

"""**Clear Memory Before Model Training**"""

import gc

gc.collect()
tf.keras.backend.clear_session()

"""**Building a CNN Model (Without Data Augmentation)**"""

from tensorflow.keras import layers, models

model = models.Sequential([
    layers.Rescaling(1./255, input_shape=(128, 128, 3)),
    layers.Conv2D(16, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(32, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(64, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

model.summary()

"""**Training the Model**"""

history = model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=30
)

"""**Plotting the Accuracy & Loss**"""

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs_range = range(30)

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend()
plt.title('Training and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend()
plt.title('Training and Validation Loss')

plt.show()

"""**Evaluating the Model**"""

loss, accuracy = model.evaluate(val_ds)
print(f"Validation Accuracy: {accuracy * 100:.2f}%")

"""**Predicting on New Images from Validation DataSet**"""

for images, labels in val_ds.take(1):
    predictions = model.predict(images)
    predicted_labels = tf.argmax(predictions, axis=1)

    plt.figure(figsize=(10, 10))
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        true_label = class_names[labels[i]]
        pred_label = class_names[predicted_labels[i]]
        plt.title(f"True: {true_label}\nPred: {pred_label}", fontsize=8)
        plt.axis("off")

"""**Clear Session Before Building a New Model**"""

import gc

gc.collect()
tf.keras.backend.clear_session()

"""**Building a ResNet50 Model**"""

from tensorflow.keras.applications import ResNet50
from tensorflow.keras import layers, models

# Load ResNet50 base
resnet_base = ResNet50(
    input_shape=(128, 128, 3),
    include_top=False,   # We will add our own classifier
    weights='imagenet'   # Use pretrained ImageNet weights
)

# Freeze the base model
resnet_base.trainable = False

# Build the full model
resnet_model = models.Sequential([
    resnet_base,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

# Compile
resnet_model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

resnet_model.summary()

"""**Training the Model**"""

history_resnet = resnet_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=20
)

"""**Plot Accuracy and Loss for the Model**"""

acc = history_resnet.history['accuracy']
val_acc = history_resnet.history['val_accuracy']
loss = history_resnet.history['loss']
val_loss = history_resnet.history['val_loss']
epochs_range = range(len(acc))

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend()
plt.title('Training and Validation Accuracy (ResNet50)')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend()
plt.title('Training and Validation Loss (ResNet50)')

plt.show()

"""**Evaluate the ResNet50 Model**"""

loss, accuracy = resnet_model.evaluate(val_ds)
print(f"Validation Accuracy (ResNet50): {accuracy * 100:.2f}%")

"""**Predicting on New Images**"""

for images, labels in val_ds.take(1):
    predictions = resnet_model.predict(images)
    predicted_labels = tf.argmax(predictions, axis=1)

    plt.figure(figsize=(10, 10))
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        true_label = class_names[labels[i]]
        pred_label = class_names[predicted_labels[i]]
        plt.title(f"True: {true_label}\nPred: {pred_label}", fontsize=8)
        plt.axis("off")

"""**Clear Session before Building a New Model**"""

import gc

gc.collect()
tf.keras.backend.clear_session()

"""**Building a MobileNetV2 Model**"""

from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras import layers, models

# Load MobileNetV2 base
mobilenet_base = MobileNetV2(
    input_shape=(128, 128, 3),
    include_top=False,    # We will add our own custom classifier
    weights='imagenet'    # Pretrained weights
)

# Freeze the base model
mobilenet_base.trainable = False

# Build full model
mobilenet_model = models.Sequential([
    mobilenet_base,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

# Compile
mobilenet_model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

mobilenet_model.summary()

"""**Training the Model**"""

history_mobilenet = mobilenet_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=20
)

"""**Plotting Accuracy and Loss for the Model**"""

acc = history_mobilenet.history['accuracy']
val_acc = history_mobilenet.history['val_accuracy']
loss = history_mobilenet.history['loss']
val_loss = history_mobilenet.history['val_loss']
epochs_range = range(len(acc))

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend()
plt.title('Training and Validation Accuracy (MobileNetV2)')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend()
plt.title('Training and Validation Loss (MobileNetV2)')

plt.show()

"""**Evaluating the Model**"""

loss, accuracy = mobilenet_model.evaluate(val_ds)
print(f"Validation Accuracy (MobileNetV2): {accuracy * 100:.2f}%")

"""**Predicting on New Images**"""

for images, labels in val_ds.take(1):
    predictions = mobilenet_model.predict(images)
    predicted_labels = tf.argmax(predictions, axis=1)

    plt.figure(figsize=(10, 10))
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        true_label = class_names[labels[i]]
        pred_label = class_names[predicted_labels[i]]
        plt.title(f"True: {true_label}\nPred: {pred_label}", fontsize=8)
        plt.axis("off")

"""**Visualizing a Comparison between all 3 Models (Simple CNN, ResNet50, and MobileNetV2)**"""

import matplotlib.pyplot as plt

# Prepare epochs ranges
epochs_cnn = range(len(history.history['accuracy']))
epochs_resnet = range(len(history_resnet.history['accuracy']))
epochs_mobilenet = range(len(history_mobilenet.history['accuracy']))

# Plot Training Accuracy
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(epochs_cnn, history.history['accuracy'], label='Simple CNN - Train')
plt.plot(epochs_cnn, history.history['val_accuracy'], label='Simple CNN - Val')
plt.plot(epochs_resnet, history_resnet.history['accuracy'], label='ResNet50 - Train')
plt.plot(epochs_resnet, history_resnet.history['val_accuracy'], label='ResNet50 - Val')
plt.plot(epochs_mobilenet, history_mobilenet.history['accuracy'], label='MobileNetV2 - Train')
plt.plot(epochs_mobilenet, history_mobilenet.history['val_accuracy'], label='MobileNetV2 - Val')

plt.legend()
plt.title('Training and Validation Accuracy Comparison')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')

# Plot Training Loss
plt.subplot(1, 2, 2)
plt.plot(epochs_cnn, history.history['loss'], label='Simple CNN - Train')
plt.plot(epochs_cnn, history.history['val_loss'], label='Simple CNN - Val')
plt.plot(epochs_resnet, history_resnet.history['loss'], label='ResNet50 - Train')
plt.plot(epochs_resnet, history_resnet.history['val_loss'], label='ResNet50 - Val')
plt.plot(epochs_mobilenet, history_mobilenet.history['loss'], label='MobileNetV2 - Train')
plt.plot(epochs_mobilenet, history_mobilenet.history['val_loss'], label='MobileNetV2 - Val')

plt.legend()
plt.title('Training and Validation Loss Comparison')
plt.xlabel('Epochs')
plt.ylabel('Loss')

plt.tight_layout()
plt.show()

"""**TRAINING THE SAME MODELS WITH DATA AUGMENTATION**"""

import gc
gc.collect()
tf.keras.backend.clear_session()

"""**Simple CNN (With Data Augmentation)**"""

cnn_aug_model = models.Sequential([
    data_augmentation,
    layers.Rescaling(1./255, input_shape=(128, 128, 3)),
    layers.Conv2D(16, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(32, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(64, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

cnn_aug_model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

cnn_aug_model.summary()

history_cnn_aug = cnn_aug_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=30
)

"""**Simple CNN Visualization (Augmented)**"""

epochs_cnn_aug = range(len(history_cnn_aug.history['accuracy']))

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_cnn_aug, history_cnn_aug.history['accuracy'], label='Train Accuracy')
plt.plot(epochs_cnn_aug, history_cnn_aug.history['val_accuracy'], label='Validation Accuracy')
plt.legend()
plt.title('Simple CNN (With Data Augmentation) Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_cnn_aug, history_cnn_aug.history['loss'], label='Train Loss')
plt.plot(epochs_cnn_aug, history_cnn_aug.history['val_loss'], label='Validation Loss')
plt.legend()
plt.title('Simple CNN (With Data Augmentation) Loss')

plt.show()

"""**ResNet50 (With Data Augmentation)**"""

gc.collect()
tf.keras.backend.clear_session()

resnet_aug_model = models.Sequential([
    data_augmentation,
    resnet_base,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

resnet_aug_model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

resnet_aug_model.summary()

history_resnet_aug = resnet_aug_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=20
)

"""**ResNet50 Visualization (Augmented)**"""

# Plotting ResNet50 (Augmented) alone
epochs_resnet_aug = range(len(history_resnet_aug.history['accuracy']))

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_resnet_aug, history_resnet_aug.history['accuracy'], label='Train Accuracy')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['val_accuracy'], label='Validation Accuracy')
plt.legend()
plt.title('ResNet50 (With Data Augmentation) Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_resnet_aug, history_resnet_aug.history['loss'], label='Train Loss')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['val_loss'], label='Validation Loss')
plt.legend()
plt.title('ResNet50 (With Data Augmentation) Loss')

plt.show()

"""**MobileNetV2 (With Data Augmentation)**"""

gc.collect()
tf.keras.backend.clear_session()

mobilenet_aug_model = models.Sequential([
    data_augmentation,
    mobilenet_base,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(class_names), activation='softmax')
])

mobilenet_aug_model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

mobilenet_aug_model.summary()

history_mobilenet_aug = mobilenet_aug_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=20
)

"""**MobileNetV2 Visualization (Augmented)**"""

# Plotting MobileNetV2 (Augmented) alone
epochs_mobilenet_aug = range(len(history_mobilenet_aug.history['accuracy']))

plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['accuracy'], label='Train Accuracy')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['val_accuracy'], label='Validation Accuracy')
plt.legend()
plt.title('MobileNetV2 (With Data Augmentation) Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['loss'], label='Train Loss')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['val_loss'], label='Validation Loss')
plt.legend()
plt.title('MobileNetV2 (With Data Augmentation) Loss')

plt.show()

"""**Final Visualization Comparing all the Augmented Models (Simple CNN, ResNet50, and MobileNetV2)**"""

# Prepare epochs ranges
epochs_cnn_aug = range(len(history_cnn_aug.history['accuracy']))
epochs_resnet_aug = range(len(history_resnet_aug.history['accuracy']))
epochs_mobilenet_aug = range(len(history_mobilenet_aug.history['accuracy']))

# Plot Training Accuracy
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(epochs_cnn_aug, history_cnn_aug.history['accuracy'], label='Simple CNN (Aug) - Train')
plt.plot(epochs_cnn_aug, history_cnn_aug.history['val_accuracy'], label='Simple CNN (Aug) - Val')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['accuracy'], label='ResNet50 (Aug) - Train')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['val_accuracy'], label='ResNet50 (Aug) - Val')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['accuracy'], label='MobileNetV2 (Aug) - Train')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['val_accuracy'], label='MobileNetV2 (Aug) - Val')

plt.legend()
plt.title('Training and Validation Accuracy Comparison (With Data Augmentation)')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')

# Plot Training Loss
plt.subplot(1, 2, 2)
plt.plot(epochs_cnn_aug, history_cnn_aug.history['loss'], label='Simple CNN (Aug) - Train')
plt.plot(epochs_cnn_aug, history_cnn_aug.history['val_loss'], label='Simple CNN (Aug) - Val')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['loss'], label='ResNet50 (Aug) - Train')
plt.plot(epochs_resnet_aug, history_resnet_aug.history['val_loss'], label='ResNet50 (Aug) - Val')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['loss'], label='MobileNetV2 (Aug) - Train')
plt.plot(epochs_mobilenet_aug, history_mobilenet_aug.history['val_loss'], label='MobileNetV2 (Aug) - Val')

plt.legend()
plt.title('Training and Validation Loss Comparison (With Data Augmentation)')
plt.xlabel('Epochs')
plt.ylabel('Loss')

plt.tight_layout()
plt.show()

"""**Visualization for the Presentation**"""

import matplotlib.pyplot as plt

# Extract final validation accuracy from each model
val_acc_cnn = history.history['val_accuracy'][-1]
val_acc_resnet = history_resnet.history['val_accuracy'][-1]
val_acc_mobilenet = history_mobilenet.history['val_accuracy'][-1]

val_acc_cnn_aug = history_cnn_aug.history['val_accuracy'][-1]
val_acc_resnet_aug = history_resnet_aug.history['val_accuracy'][-1]
val_acc_mobilenet_aug = history_mobilenet_aug.history['val_accuracy'][-1]

# Data for the bar chart
models = ['CNN', 'ResNet50', 'MobileNetV2']
before_aug = [val_acc_cnn, val_acc_resnet, val_acc_mobilenet]
after_aug = [val_acc_cnn_aug, val_acc_resnet_aug, val_acc_mobilenet_aug]

# Plotting
x = range(len(models))
bar_width = 0.35

plt.figure(figsize=(10, 6))
plt.bar(x, before_aug, width=bar_width, label='Before Augmentation', color='skyblue')
plt.bar([p + bar_width for p in x], after_aug, width=bar_width, label='After Augmentation', color='orange')

plt.xlabel('Model')
plt.ylabel('Validation Accuracy')
plt.title('Validation Accuracy Comparison Before and After Augmentation')
plt.xticks([p + bar_width / 2 for p in x], models)
plt.ylim(0.4, 1.0)
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()